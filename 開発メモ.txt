連結演算においてブランクの無視はどう扱うべきか？



(alphabet | '_') + (alphabet | numeric | '_').Above0 の間に空白が割り込んでしまうのはマズい。
パーサ以前にトークナイザで処理する方式なら、正規表現で１トークンにしてしまえるので、問題は発生しなかった。
Parspellでは直接パーサで処理するので、空白が割り込まないようにする必要がある。

そもそも、空白を無視してはいけない状況とは？
	空白で区切られた要素を連結する時
		BNFでの要素の連続、関数型言語の引数、など
			オフサイドルールの場合、空白を挟んでも良いが改行を挟んではいけない事もある。
	識別子のように１文字目と２文字目以降を空白を挟まず連結させる時
	コメントや文字列リテラルのように、開始文字に続く空白も無視してはいけない時


文字マッチャーにおいて、走査位置が文字列末尾で、末尾トークンに対してマッチングを試みると、
長さ１の失敗マッチを生成してしまっている。


マッチ失敗の場合、問答無用でインデントをロールバックしているが、
aaaa.Not の場合、aaaaが失敗した時点でロールバックされ、
aaaa.Notで成功マッチに変換されるのに、ロールバックをなかったことにできない。

解決策の案
	〇〇Notマッチャーを〇〇の数だけ用意し、
	aaaa.Notプロパティでは、その〇〇Notマッチャーを返す。
別の解決策の案
	成功マッチに変換される際、ロールバックをなかった事にする。
	そもそもロールバックの処理を「過剰要素を消す」から「実際の要素を削らずに見かけの要素数を戻す」
	という処理に変える。
	マッチにインデントリストの要素数を格納しておき、成功に変換されると「見かけの要素数」を戻す。
	
	マッチに真の時のインデントリストの要素数・偽の時のインデントリストの要素数をそれぞれ保持させれば実装できそう。

